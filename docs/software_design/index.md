# 软件设计之美

软件设计学习的难度，不在于一招一式，而在于融会贯通。

## 分离关注点

大多数系统设计的不够好，问题常常出在分解这步没做好。常见的分解问题就是分解粒度太大，把各种维度混淆在一起（比如技术维度和业务维度）。 举个例子，比如因为存储性能不够，又是批量又是缓存，代码写的很麻烦。但其实最根本的解决之道 是找一个性能较高的存储。

## 如何了解一个软件的设计

~~~mermaid
graph LR;
  模型 --> 接口 --> 实现
~~~

- 模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。
- 接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。
- 实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。

我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。如果模型都还没有弄清楚，就贸然进入细节的讨论，你很难分清哪些东西是核心，是必须保留的，哪些东西是可以替换的。如果你清楚了解了模型，也就知道哪些内容在系统中是广泛适用的，哪些内容必须要隔离。

但如果只知道这些，你只是在了解别人设计的结果，这种程度并不足以支撑你后期对模型的维护。在一个项目中，常常会出现新人随意向模型中添加内容，修改实现，让模型变得难以维护的情况。造成这一现象的原因就在于他们对于模型的理解不到位。

我们都知道，任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。也就是说，理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。

## 程序设计语言

程序设计语言的发展就是一个“逐步远离计算机硬件，向着待解决的问题靠近”的过程。

程序库就是为了消除重复而出现的。而消除重复，也是软件设计的初衷。

程序库最初只是为了消除重复。后来，逐渐有了标准库，然后有了大量的第三方库，进而发展出包管理器。程序设计语言的接口不只包含语法，还有程序库。而且，学习一种程序设计语言提供的模型时，不仅仅要看语法本身有什么，还要了解有语言特性的一些程序库。语法和程序库是在解决同一个问题，二者之间是相互促进的关系。一些经过大量实践验证过的程序库会变成语言的语法；如果语法不够好，新的程序库就会出现，新一轮的编程模型就开始孵化。比如

~~~mermaid
graph LR;
  synchronized --> aqs --> synchronized
~~~

## 设计原则

软件设计是一门关注长期变化的学问。一个模块应该有且仅有一个变化的原因。一个模块最理想的状态是不改变，其次是少改变，它可以成为一个模块设计好坏的衡量标准。需求为什么会改变？因为有各种提出需求的人，不同的人提出的需求，其关注点是不同的。

- 单一职责原则（Single responsibility principle，SRP）
- 开放封闭原则（Open–closed principle，OCP）
- Liskov 替换原则（Liskov substitution principle，LSP）
- 接口隔离原则（Interface segregation principle，ISP）
- 依赖倒置原则（Dependency inversion principle，DIP）

## 设计模式

如果用数学来比喻的话，设计原则就像公理，它们是我们讨论各种问题的基础，而设计模式则是定理，它们是在特定场景下，对于经常发生的问题给出的一个可复用的解决方案。设计模式之所以能成为一个特定的解决方案，很大程度上是因为它是一种好的做法，符合软件设计原则，所以，设计原则其实是这些模式背后的东西。

学习设计模式，我们应该有一个更开阔的视角：要看到语言的局限，虽然设计模式本身并不局限于语言，但很多模式之所以出现，就是受到了语言本身的限制。比如，Visitor 模式主要是因为 C++、Java 之类的语言只支持单分发，也就是只能根据一个对象来决定调用哪个方法。而对于支持多分发的语言，Visitor 模式存在的意义就不大了。PS：比如golang有了channel，则观察者订阅者模式的意义就不大了。

[设计模式](https://refactoringguru.cn/design-patterns)
